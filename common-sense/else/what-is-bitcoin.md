# 自己理解的比特币与区块链

为什么会有比特币的出现，恐怕才是我应该思考的问题，这才能和自己的专业方向结合起来，不过目前还不能完全地了解其中的思想，因此还是从技术上先进行学习。从如何创造一个bitcoin开始了解。
## 1.账本
首先从一个用于记录你与好友们之间交易信息的公共账本开始。为什么需要这个账本呢？因为朋友之间交易，总是用现金不方便，不如先把信息记录下来，未来统一结账。账本如何使用，大家之间需要事先说明一些规则：每个人都得先交一笔钱，不然到最后，有人入不敷出了，结果逃跑了，就没办法整，这条就需要系统了解截止当前所有的历史交易信息，否则无法计算收入和支出的情况，这点倒是目前仍在优化的地方，不过这点也去掉了账本和真实货币之间的关系，理论上如果所有人都用这么一个账本，那人的一生都可以在这个账本上支付收入就行了；然后，每个人都可以往账本里面写信息，比如A支付给B 100元，当然每个人也可以读取账本的信息，账本对所有人公开。

现在问题就来了，这东西方便是方便，但是人都是有阴暗面的，你不可能保证所有人都守信用，不违规，假如B起了贼心，他想阴A 100块钱，他就在A不注意的时候，在账本里写了一条A支付给B 100元，这种情况怎么限制呢？或者说，怎么让账本一直都可信呢？怎么防止账本信息被伪造呢？

为了防止信息伪造，需要每一条支付信息都被付款人知情，为了保证付款人知情，一个自然而然的想法就是支付信息要有付款人的签名，与纸质的签名不同，在这个账本上，使用付款人的数字签名，当然为了防止数字签名被伪造，我们就需要使用加密技术，制造一个不可能被伪造的数字签名出来，这样，就可以放心的使用数字签名了。

为了更清楚地说明账本中的哈希加密技术，还是从加密以及哈希这两个东西开始说起。
## 2.加密
### 2.1 加密的基本逻辑
加密，一个现实中，经常见到的词汇，为什么呢？

古代的时候，当人们还只是近距离进行交流的时候，如果想要加密，只要像下图这样就可以了。

![](stock-vector--pop-art-style-comic-book-panel-gossip-girl-whispering-in-ear-secrets-with-speech-bubble-rumor-654506083.jpg)

可是当人们想要远距离进行交流时，就得进行一项重要活动——通信。我们人类通信的基本手段之一是利用电磁波进行通信，使用电磁波通信时发送信息者需要把自己的信息先通过编码的方式转化为可以通过电磁波进行传递的信息，然后通过电磁波发射给接收方，接收方再通过解码的方式把电磁波中的信息转化为可以理解的信息。

假如现在小y和小f想要进行远距离通信，他们之间聊得是私密的话题，他们不想让别人听到，现在小y给小f发送一条信息“我中意你”，他知道小q可能会监听他发送的信号，毕竟电磁波是公开传播的，不管是通过有线方式还是无线的方式，但是他不想让情敌小q知道他说的是什么，那么他就得让他的信息的解码方式对小q保密。这个保密的过程就是加密。

![](communicate.jpg)

那么如何进行加密过程呢？小y需要把它的编码技术变得难以解码，这需要在之前编码的信息上再加一道工序，把原来的信息（明文）变为加密的信息（密文），而小f需要得到密文之后，需要能够进行逆向计算，就是把密文再变为明文，而不能让小q进行逆向运算，即小q拿到密文之后，他是不知道怎么解密的。

这方面比较早的做法是凯撒加密，大致是这样的，把所有字母变为其在字母表中对应的后x位的字母，比如iloveyou，后移一位变成jmpwfzpv，就变成了奇奇怪怪的话了，而小f知道是后移一位的，那么她只要反过来进行运算，很容易就得到了iloveyou。小q想要知道jmpwfzpv就不是那么轻松了，当然，现代密码学里，这已经是非常简单的事情了，因为凯撒密码是有致命缺陷的，因为当字符数很小时，通过枚举我们可以很容易的解密，当字符比较多的时候，由于26个字母在文本中出现的频率是不同的，字符比较多时，根据大数定律，字母的频率势必是接近总体的情况的，因此，我们只要计算文本中字母出现的频率，就可以知道哪些字母对应了原来的字母的。当然后来势必有一些改进的方法（自己yy的），但是只要存在有规律的信息，或者只要有信息被泄露出来，总会有相对可行的解密方法，这样这种加密方式就是不完全加密的，也就是说，不必穷举，就可以进行解密的，而我们势必要找到一种可以完全加密的，就是让信息对于窃听者来说是完全加密的，即除了穷举没有更好的办法，而又必须让接受者可以很轻易的解密。

现在最常见的加密方法就是RSA加密算法。理解这套加密算法，也是理解区块链技术的很重要的地方。这套加密算法的关键在于寻找一个算法，对于接受信息的人来说，这套算法是可逆的，而对于窃听者来说这套算法是不可逆的，也就是对于小q来说不可逆，对于小f是可逆的。所以怎么找这样一个算法的。

还是举例分析，先将上述过程表述为小y给小f一条信息message，然后通过一个算法f，得到一条加密信息secret，即
f(message)=secret，小q拿到secret，不能进行f^(-1)的逆向运算，而小f能进行f^(-1)(secret)=message的逆向运算。

那么我们自己想象下，需要什么样的技巧呢？首先，我们需要一个单向函数，也就是说正向容易反向不容易，这就构成了加密或者说锁的基本道理，就像生活中的锁一样，比如门锁，关门很容易，但是开门就需要钥匙了，没错，解密就需要钥匙。那么我们还需要让这个钥匙只能让信息接收者获取而不能让窃听者获取，这就是最关键的技巧了。现在一一分析这两部分内容。

### 2.2 加密的单向函数
单向函数就是正向容易，反向不容易的函数，在数论中可以找寻答案。
#### 离散对数问题
第一个就是模运算中出现的离散对数问题。什么是求模运算呢？模运算可以理解为正整数的求余数运算，这里我们关心除数是质数的情况，而被除数我们关系的是质数的次方这样的数，为什么呢？因为这样的数能构成单向函数，我们取一个质数3，一个质数17，对于等式 x^3 mod 17 = y ，在已知x的情况下，求y是容易的，但是反过来是非常困难的，除了穷举，似乎没有更好的办法，为什么呢？因为x^3 mod 17这种运算，x取值变化的时候，余数在1-17之间是等概率的，也就是说是完全随机的，这也就是完全加密的了。
#### 分解质因数
第二个就是从算术基本定理得来的。算术基本定理是关于合数质数的定理，是说任意一个合数都能分解为唯一的质因数乘积组合，这个定理是二千多年前欧几里得证明过的。且分解质因数的过程是困难的，除了穷举没有很好的办法，为什么呢？因为质数的变化没有规律可言，虽然这没有被证明，但是人们至今还没有发现规律。
### 2.3 解密的关键
解密的过程需要对接受信息者容易，而对窃听者困难。也就是只能让接受者能拿到开锁的钥匙，而窃听者是拿不到的。这要怎么做呢？
#### 基本逻辑
基本的逻辑是把解密的信息分割，不然很难保证窃听方不能窃听到信息，也就是把钥匙分成两份，一份称为公钥public key，简称pk；一份称为私钥，private
 key，也可以叫走secret key，简称sk。pk用于信息交流着之间传播，而私钥则各自拥有或者只让需要解密的一方拥有，假如接受方小f是解密的，那么只让小f有私钥。没有私钥就无法开锁，这样只能拿公钥的窃听者是不可能解密的。

对于前者，在交流开始之前，小y和小f先就公用同一个公钥达成一致，然后双方各自私底下随机生成一个私钥，小y利用自己的私钥和公钥生成了一个信息，然后将这个信息给小f，小f也同样用自己的私钥和公钥生成另一个信息，他把这个信息发给小y，双方利用对方发来的信息，再结合自己的私钥能够得到一个相同的信息，这个信息就可以作为共享的密钥了。

 因为RSA加密属于后者，因此我们只详细讨论后者，即一方有私钥的情况，这也是为什么RSA更好用的一个重要原因，就是它只需要一方有私钥，更方便。它的基本思路是这样的，小y想要给小f发消息，需要首先让小f给他一把打开的锁，然后小y拿到这个打开的锁之后，只要把自己的信息用锁锁好，然后再发给小y就可以了，因为整个过程压根就没有传输钥匙，所以是加密的，我们仍然采用建公钥、私钥的叫法，因此这把打开的锁就是pk，小f自己拥有的钥匙是sk。这样的pk和sk如何实现呢，加密和解密的过程又是怎么回事呢？

这个逻辑进一步地可以这样理解。小y想要给小f一条信息，首先他把这个信息转化为一个数字m，这个直接用ascii码就可以轻易实现了，然后小y现在就要把m加密后发给小f，首先双方声明一个公用的pk，然后利用这个pk小y就可以加密了，加密函数我们用F表示，则F(m,pk)=s，s是加密后的信息，F是一个单向函数，根据m、pk得到s容易，但是根据s，pk得到m是很难的。这样把s发送给小f，小q是无法解密的，但是小f拿到s、pk之后，再结合sk，就能很容易地计算出m了，即有一个函数G，使得G(s,pk,sk)=m。这样整个过程就实现了。

接下来就是详细地介绍一下F、G、pk、sk、s这些都是怎么回事了。
 #### 单向函数的妙用
从以上的过程就可以看出来，我们需要一个函数F，这个函数有这样的特点，首先，它是一个单向函数，也就是F(m,pk)=s很容易，而F^(-1)(s,pk)=m几乎不可能，且与此同时，如果我们有更多的信息——sk，我们就可以有一个函数G，使得G(s,pk,sk)=m。

这个F函数就是离散对数问题中的运算函数，m ^ e mod n = c 。c是加密后的信息，e和n一起作为公钥，而sk是d，d有这样的特点，有函数G，c ^ d mod n = m。

从m ^ e mod n = c和c ^ d mod n = m两个式子中，我们可以得到(m ^ e mod n) ^ d mod n = m。然后化简为m^(ed) mod n = m。这个式子貌似不是很好推，毕竟mod运算的推导，还是挺少见的，这里采用一种抽象化的思维方式，利用mod运算的等式表达来进行分析，我们记m ^ e mod n = c为m ^ e ≡ c (mod n)（这就是“同余”的概念），同理有c ^ d ≡ m (mod n)，因此根据等式的传递性，有(m ^ e) ^ d ≡ m (mod n)，也就是(m ^ ed) ≡ m (mod n)，也就是m^(ed) mod n = m。

现在问题的关键就是d和e（还有n）是如何生成的了，也就是私钥和公钥如何生成的问题是最关键的了，这里仍然需要一个单向函数，也就是根据d生成e简单，而由e生成d困难，否则小q拿到e之后，它就能推出d来了，那加密就失败了。这样就是第二个单向函数出马的时候了。让我们再次回归整个过程：

首先，小f利用随机数生成器随机生成一个几百位的质数p，然后再随机生成一个差不多大小的几百位的质数q，然后p*q=n，得到一个合数n，然后再随机生成一个不大的质数e，这样公钥就有了，即n和e组成pk，小f把pk发给小y；

然后小y拿到n和e之后，结合自己文本信息通过函数计算出来的m，
可以计算m ^ e mod n = c，得到c，这样信息就被加密了，它把c发回给小f；

小f拿到信息之后，就要着手解密了，他需要求出满足等式m^(ed) mod n = m的d，才能有c ^ d mod n = m，才能解开加密信息。如何求呢？借助欧拉定理。

一，欧拉在欧几里得的基础上，继续分析了质数的相关特性，他定义了一个Φ函数，n是一个正整数，则Φ(n)表示小于n的正整数里，与n互质的数的个数。Φ(n)有一个很有趣的特性，是Φ(x1*x2)=Φ(x1)*Φ(x2)，另外考察Φ(n)的特性可以发现当n是质数时，有Φ(n)=n-1，但是计算Φ(n)是一个非常困难的事情，除非我们知道n是如何因式分解的，比如n = p * q，则Φ(n)=(p-1) * (q-1)。

二，要把Φ(n)函数和模运算结合起来，这就用到了欧拉定理是这样的，m和n互质，则有m ^ Φ(n) ≡ 1 (mod n)。怎么结合呢？首先等式两边同时求k次方，有m ^ (Φ(n) * k) ≡ 1 (mod n)，然后等式两边再同时乘以m，有m ^ (Φ(n) * k + 1) ≡ m (mod n)，也就是m ^ (Φ(n) * k + 1) mod n = m。这就得到了等式m^(ed) mod n = m的形式了，所以d=(Φ(n) * k + 1)/e，由于小f自己用两个质数求出的n，因此他很容易得到d，然而，小q只知道n，他是算不出p和q的，因此他也就算不出来d了，所以加密解密成功！

## 3 哈希
哈希和加密是两个不同的东西。hash是将目标文本转换成具有相同长度的、不可逆的数字串，加密则是将目标文本转换为可逆的密文。使用相同的hash算法，不管你的输入有多长，得到的结果长度是一个常数。
一个hash算法R=H(S)是一个多对一的映射，给定目标文本S，H可以将其唯一映射为R，并且对所有S，R具有相同的长度，由于是多对一的映射，所以H不存在逆映射。一个好的hash算法应该很难从结果找出原文本，对输入很敏感，微小的变化，都会使结果产生极大的改变。当被保护的数据仅仅用作比较验证，在以后不需要将其还原成明文形式时，采用hash而不采用加密。
现在讨论一次哈希进行数据保护的方法。这也是我们在开发系统中经常做的，就是利用md5或者sha1算法进行密码加密及验证，详见下图![](hashcrypt.jpg)
密码哈希算法非常复杂，因此不必详细了解了。
## 4 账本中的信任危机的解决
好了，捣鼓了半天的加密，到其实数字签名里用到的密码hash算法和加密解密算法不是一回事，现在来看看数字签名是怎么回事。数字签名其实是经过加密后得到的数字，它是一串0和1组成的数字，通常长度是256位。它是怎么得到的呢？就是现在账本上有很多信息了，账本上的所有信息是message，现在你用前面讲到的公钥和私钥的生成方法，生成一个私钥sk，并且自己保存，数字签名signature=sign(message,sk)，然后还有一个验证函数，这个验证函数是这样的verify(message,signature,pk)=T/F。signature对外人来说是加密的，如果想要伪造一个signature使得verify结果为T，只有穷举的办法才能做到，也就是说对外公开的信息是message，pk和verify函数，sk和signature都是秘密，这里面用到了哈希，也用到了加密。

接下来，我自己猜一下这里面大概的道道，作为自己的理解方式，因为我也没必要弄懂里面的道理。首先是自己要生成一对密钥，一个pk和一个sk，生成过程是这样的，先随机生成两个大小差不多的质数p和q，然后求p*q=n，随机生成一个质数e作为公钥pk，然后利用公式d=(Φ(n) * k + 1)/e（关于k是怎么定的，可以参考扩展欧几里得算法）求出d作为私钥sk，这对pk与sk不是用来还原信息的，而只是用来验证信息的，即仅仅验证signature是否是正确的。，怎么进行验证呢？我猜首先是sha算法把message转换成一个hash码，然后这个hash码作为一个数字m，接下来用于和之前加密一样的过程里，m和sk一起进行一个正向计算，m ^ sk mod n = c ，这个c是hash数字签名加密了的数字也就是signature，然后verify里的message可以用相同的hash算法算出来m，然后c（也就是signature）和pk如果能还原出m，那么验证成功，如果没有还原出m，则验证为F。（注：这段纯属个人瞎yy，只为把逻辑走通）
对于256位的signature，想找到一个正确的signature，在没有sk的情况下除了穷举没有更好的办法去验证，2^256次方有多大，天文数字！

现在加密的事情就解决了，还有一点小问题需要应对，那就是这种情况：当A确实要支付给B 100块的时候，B起了贼心，他把这个带有数字签名的信息复制了好几份，这下怎么办呢？这就要求每条交易信息都必须有一个编号，不能随意复制，或者每个人他自己的每条信息都有一个唯一的时间戳，这样就不能随意被复制了。
## 5 分布式账本
以上就是理解比特币的一些比较重要的概念了，实际上就是一个账本，所有的历史交易总和就是当前的货币情况，当然对于比特币账本上就只能用比特币进行交易了，你必须花费一笔现金，购买比特币，或者自己制造新的比特币，这个之后再说。

现在的问题是我们的账本要放到哪里？

如果放到一个网站，那么我们所有人都必须信任这样一个机构，这实际上是非常困难的事情，即使是在我们社会主义国家，腐败都是很难避免和治理的。因此我们换个思路，所有人一起来管理这个账本，所有人都能获取这个账本，那这样就不需要中心机构了。设想A支付给B 100元，A记录了这条信息并且要把这条信息给广播出去，让网络中所有的其他人都知道这么个事，其他人收到了这条信息，就要把这条信息放在自己存的那个账本里，这看起来很好，但是其实是一个很糟糕的设计，因为如何确保所有人手里都是正确的账本呢？比如B收到了一个A支付给B 100元的信息，但是如果其他人没有收到这条信息，那么那么他就相当于损失了100元，因为和他交易的人如果不知道他有这100元的收入，他的购买力就减少了100元。那么他如何确保其他所有人都能收到同样的这条信息呢？能让他以后和其他人交易的时候可以用着100元。

## 6 区块链
现在试着想想，是自己收听来自外界的交易信息广播，要如何确保其他人和你一样以相同的顺序接受交易信息以使大家都形成同样的一份账单呢？这才是关键所在！这也是比特币的原始论文里面的详述的部分。

**敲黑板！重点来了：**

比特币的方法是选择信任消耗最多计算资源的那份账本。

与之相关的是SHA256算法，它和计算力有什么关系呢？

现在的账本下，如果你能在账本末尾添加一个特殊数字，它使得整个账本的信息在做了SHA256算法之后，得到的256位0或者1的数字的前30位都是0。那么……我们先不考虑那么能干什么，先考虑找到这个数字有多难。对于一个随机的信息，其散列值前30位都是0的概率是2^30次方分之一，差不多是10亿分之一。因为SHA256算法之前已经提到过是一个不可逆的算法，因此找到这个特殊数字的唯一方法只能是穷举验证，也就是试，所以一个人差不多试了10亿次，才能找到一个这样的特别数字。这个特殊数字我们称之为“工作量证明”，如果你改变账本的信息，那么就得再用十亿次的计算得到这么个数。

在分布式的账本中，每个人都信任消耗工作量最大的那个账本，要实现这个想法，首先要把账本整理成区块，也就是每个工作量证明作为一个区块的结束，区块们包含了一系列交易信息及工作量证明。一个区块，只有当它有工作量证明时，才被认为是有效的。为了确保这些区块是有顺序的，我们规定当前区块的头部必须要加上前一个区块的散列值，这样的话，如果你想回头改变某个区块的内容，你就会改变它之后的所有区块的内容，那就需要重新计算后面所有区块的散列值，因为区块链式地连接在一起，因此成为区块链！

现在我们允许所有人能成为区块的建立者，即他们将收听网络中的交易信息，整理这些信息生成区块，然后花大量的计算寻找特别的数字，一旦找到这个数字，他们就将这个区块广播出去，为了奖励这个区块建立者的工作付出，规定当他建立了一个区块，他可以把一笔特别的交易信息（奖励给他一些比特币）放在账本开头，这是接受或拒绝交易信息规则的一个例外，它不来自任何人，所以也不需要签名，这就意味着整个网络中的比特币会随着新区快的产生而增加，这就是挖矿！

所以一个矿工实际上就是在收听信息，建立区块，广播区块，获得奖励。区块就像一个彩票，每个人都想最快的猜出来这个数字，知道其中一个人找到了特别数字，然后他就得到奖励。

对于只想利用这个系统交易的人，并不需要收听交易信息，他们只需要收听矿工广播的区块即可。然后更新自己的那一份区块链。现在如果收到了两份不同区块链，那么相信哪一份呢？当然是相信更长的了。

所有人都在自己维护自己的那份区块链，每个人都信任最多工作量的那个区块链，我们所有人就共同达成了一个去中心化的共识，那么这个系统有多安全呢？
## 7 区块链交易有多可靠
我们尝试在这个系统汇总伪造信息欺骗他人，看看这有多难。比如A伪造了一个区块，这个区块里面的信息是A支付给B 100元，A只把它广播给了B，而不广播给其他人，这样来骗bob，她就仍能拥有100元，那么她要比其他所有矿工先找到工作量证明才能欺骗所有人，因为B那里也会受到别人计算得到的区块，如果过一段时间别人的新区块来的比A的多，那么B就相信别人的了，而别人的区块链里没有A支付给B 100元的信息，那么B就知道A在欺骗自己了。

A要比其他所有矿工先找到工作量证明的难度有多大呢？一个区块，还有可能A比其他人恰好都快，但是因为一个区块不同，后面的区块都会不同，所以A要一直计算下去，并且一直比所有人都快，那这显然是及其不可能的。

所以一开始不会立即信任收到的新的区块，而是等到后面有新的区块添加后，并且还没有收到更长的区块链，这个时候才相信刚刚收到的那个新区块。

这就是基于工作量证明的分布式账本系统。
## 8 比特币的有限性
现实的比特币体系中，sha256计算得到的前面多少位为0是变化的，以保证平均每10分钟产生一个新的区块，当有越来越多的矿工加入其中，为了赢得工作量证明，计算越来越难。比特币体系中所有的比特币都来源于生成新区块的奖励。一开始每个区块50个比特币，每过210000个区块，差不多没四年，区块奖励就减半，因为这个奖励随着时间等比减少，这是个等比数列的级数求和，最终是收敛的，详细可见大一微积分。不过除了区块奖励，矿工还可以获得交易费，每当你支付时，你可以选择一笔小交易费给矿工，以鼓励矿工将包含你这笔交易信息的区块广播给网络中的其他人。比特币每个区块约包含2400笔交易记录，因此比特币交易费还是比较贵的。
## 9 除了比特币，区块链还有什么用途


参考资料：
[1]youtube，3blue1brown，ever wonder how bitcoin actually work?
[2]可汗学院 古代密码学
[3]可汗学院 现代密码学
